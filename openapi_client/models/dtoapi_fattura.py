# coding: utf-8

"""
    MediHome-CloudServer

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Any, ClassVar, Dict, List, Optional, Union
from pydantic import BaseModel, StrictFloat, StrictInt, StrictStr
from pydantic import Field
from openapi_client.models.dtoapi_anagrafica import DTOAPIAnagrafica
from openapi_client.models.dtoapi_azienda import DTOAPIAzienda
from openapi_client.models.dtoapi_categoria import DTOAPICategoria
from openapi_client.models.dtoapi_fattura_item import DTOAPIFatturaItem
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class DTOAPIFattura(BaseModel):
    """
    DTOAPIFattura
    """ # noqa: E501
    data_fatturazione: Optional[datetime] = Field(default=None, alias="DataFatturazione")
    data_creazione: Optional[datetime] = Field(default=None, alias="DataCreazione")
    categoria_documento: Optional[DTOAPICategoria] = Field(default=None, alias="CategoriaDocumento")
    codice_documento: Optional[StrictStr] = Field(default=None, alias="CodiceDocumento")
    mittente: Optional[DTOAPIAzienda] = Field(default=None, alias="Mittente")
    destinatario: Optional[DTOAPIAzienda] = Field(default=None, alias="Destinatario")
    item_fattura: Optional[List[DTOAPIFatturaItem]] = Field(default=None, alias="ItemFattura")
    sub_totale: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="SubTotale")
    totale_iva: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="TotaleIva")
    totale_sconto: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="TotaleSconto")
    totale: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="Totale")
    note: Optional[StrictStr] = Field(default=None, alias="Note")
    stato_pagamento: Optional[DTOAPICategoria] = Field(default=None, alias="StatoPagamento")
    tipologia_pagamento: Optional[DTOAPICategoria] = Field(default=None, alias="TipologiaPagamento")
    condizioni_pagamento: Optional[DTOAPICategoria] = Field(default=None, alias="CondizioniPagamento")
    assistito: Optional[DTOAPIAnagrafica] = Field(default=None, alias="Assistito")
    __properties: ClassVar[List[str]] = ["DataFatturazione", "DataCreazione", "CategoriaDocumento", "CodiceDocumento", "Mittente", "Destinatario", "ItemFattura", "SubTotale", "TotaleIva", "TotaleSconto", "Totale", "Note", "StatoPagamento", "TipologiaPagamento", "CondizioniPagamento", "Assistito"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of DTOAPIFattura from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of categoria_documento
        if self.categoria_documento:
            _dict['CategoriaDocumento'] = self.categoria_documento.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mittente
        if self.mittente:
            _dict['Mittente'] = self.mittente.to_dict()
        # override the default output from pydantic by calling `to_dict()` of destinatario
        if self.destinatario:
            _dict['Destinatario'] = self.destinatario.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in item_fattura (list)
        _items = []
        if self.item_fattura:
            for _item in self.item_fattura:
                if _item:
                    _items.append(_item.to_dict())
            _dict['ItemFattura'] = _items
        # override the default output from pydantic by calling `to_dict()` of stato_pagamento
        if self.stato_pagamento:
            _dict['StatoPagamento'] = self.stato_pagamento.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tipologia_pagamento
        if self.tipologia_pagamento:
            _dict['TipologiaPagamento'] = self.tipologia_pagamento.to_dict()
        # override the default output from pydantic by calling `to_dict()` of condizioni_pagamento
        if self.condizioni_pagamento:
            _dict['CondizioniPagamento'] = self.condizioni_pagamento.to_dict()
        # override the default output from pydantic by calling `to_dict()` of assistito
        if self.assistito:
            _dict['Assistito'] = self.assistito.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of DTOAPIFattura from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "DataFatturazione": obj.get("DataFatturazione"),
            "DataCreazione": obj.get("DataCreazione"),
            "CategoriaDocumento": DTOAPICategoria.from_dict(obj.get("CategoriaDocumento")) if obj.get("CategoriaDocumento") is not None else None,
            "CodiceDocumento": obj.get("CodiceDocumento"),
            "Mittente": DTOAPIAzienda.from_dict(obj.get("Mittente")) if obj.get("Mittente") is not None else None,
            "Destinatario": DTOAPIAzienda.from_dict(obj.get("Destinatario")) if obj.get("Destinatario") is not None else None,
            "ItemFattura": [DTOAPIFatturaItem.from_dict(_item) for _item in obj.get("ItemFattura")] if obj.get("ItemFattura") is not None else None,
            "SubTotale": obj.get("SubTotale"),
            "TotaleIva": obj.get("TotaleIva"),
            "TotaleSconto": obj.get("TotaleSconto"),
            "Totale": obj.get("Totale"),
            "Note": obj.get("Note"),
            "StatoPagamento": DTOAPICategoria.from_dict(obj.get("StatoPagamento")) if obj.get("StatoPagamento") is not None else None,
            "TipologiaPagamento": DTOAPICategoria.from_dict(obj.get("TipologiaPagamento")) if obj.get("TipologiaPagamento") is not None else None,
            "CondizioniPagamento": DTOAPICategoria.from_dict(obj.get("CondizioniPagamento")) if obj.get("CondizioniPagamento") is not None else None,
            "Assistito": DTOAPIAnagrafica.from_dict(obj.get("Assistito")) if obj.get("Assistito") is not None else None
        })
        return _obj


